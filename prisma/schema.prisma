// This is your Prisma schema file

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    Int               @id @default(autoincrement())
  email                 String            @unique
  password              String?
  googleId              String?           @unique
  provider              String            @default("email") // email, google
  role                  String            @default("user") // user, admin
  planType              String            @default("free") // free, pro_trial, pro_paid
  trialStartDate        DateTime?
  subscriptionEndDate   DateTime?
  monthlyQuestionCount  Int               @default(0)
  lastQuestionResetDate DateTime?         @default(now())
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  practiceSessions      PracticeSession[]
  answers               Answer[]
  payments              Payment[]
  events                Event[]
  questionViews         QuestionView[]
  conversationMemory    ConversationMemory[]
  resumeProfile         ResumeProfile?
  jobRecommendations    JobRecommendation[]
  flashcardProgress     FlashcardProgress[]
  jobMatcherPreferences JobMatcherPreferences?
  jobMatchRuns          JobMatchRun[]
  userSecrets           UserSecret[]

  @@index([email])
  @@index([googleId])
  @@index([planType])
}

model Question {
  id          Int             @id @default(autoincrement())
  text        String          @db.Text
  category    String          // Categories from NextLeap: Guesstimates, Product Design, Metrics, Product Strategy, Root Cause Analysis, etc.
  tags        String?         @db.Text // JSON array as string - additional metadata
  source      String          @default("nextleap") // nextleap, curated, user_generated
  company     String?         @db.Text // JSON array of companies where question was asked
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  answers         Answer[]
  views           QuestionView[]
  exemplarAnswers ExemplarAnswer[]

  @@index([category])
  @@index([source])
}

model PracticeSession {
  id          Int       @id @default(autoincrement())
  userId      Int
  status      String    @default("active") // active, completed
  startedAt   DateTime  @default(now())
  endedAt     DateTime?
  
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  answers           Answer[]
  conversationMemory ConversationMemory[]
  
  @@index([userId])
  @@index([status])
}

model Answer {
  id                Int              @id @default(autoincrement())
  practiceSessionId Int?             // Nullable for anonymous users
  userId            Int?             // Nullable for anonymous users
  questionId        Int
  answerText        String           @db.Text
  transcript        String?          @db.Text // Future use for voice transcripts
  timeTaken         Int?             // Time in seconds (nullable for backward compatibility)
  status            String           @default("submitted") // submitted, scored, needs_review
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  
  practiceSession   PracticeSession? @relation(fields: [practiceSessionId], references: [id], onDelete: Cascade)
  user              User?            @relation(fields: [userId], references: [id], onDelete: Cascade)
  question          Question         @relation(fields: [questionId], references: [id], onDelete: Cascade)
  scores            Score?
  events            Event[]
  
  @@index([practiceSessionId])
  @@index([userId])
  @@index([status])
}

model Score {
  id              Int       @id @default(autoincrement())
  answerId        Int       @unique
  structure       Int       // 0-10
  metrics         Int       // 0-10
  prioritization  Int       // 0-10
  userEmpathy     Int       // 0-10
  communication   Int       // 0-10
  feedback        String    @db.Text
  sampleAnswer    String    @db.Text
  totalScore      Int       // Sum or average
  status          String    @default("completed") // completed, needs_review
  tokensUsed      Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  answer          Answer    @relation(fields: [answerId], references: [id], onDelete: Cascade)

  @@index([answerId])
  @@index([status])
}

model Payment {
  id                      Int       @id @default(autoincrement())
  userId                  Int
  razorpaySubscriptionId  String?   @unique
  razorpayCustomerId      String?
  razorpayPaymentId       String?
  amount                  Int       // in paise (INR) or cents (USD)
  currency                String    @default("usd") // usd or inr
  status                  String    // pending, completed, failed, cancelled
  subscriptionType        String?   // free, pro
  subscriptionEndDate     DateTime?
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt
  
  user                    User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([razorpaySubscriptionId])
}

model Event {
  id          Int       @id @default(autoincrement())
  userId      Int?
  answerId    Int?
  eventType   String    // api_request, openai_call, error, webhook
  metadata    String?   @db.Text // JSON metadata
  tokensUsed  Int       @default(0)
  createdAt   DateTime  @default(now())
  
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  answer      Answer?   @relation(fields: [answerId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([answerId])
  @@index([eventType])
  @@index([createdAt])
}

model QuestionView {
  id          Int       @id @default(autoincrement())
  userId      Int
  questionId  Int
  viewedAt    DateTime  @default(now())
  
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  question    Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([userId])
  @@index([questionId])
}

model AnonymousSession {
  id                  Int       @id @default(autoincrement())
  fingerprint         String    @unique
  ipAddress           String
  questionCount       Int       @default(0)
  lastQuestionDate    DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  
  @@index([fingerprint])
  @@index([ipAddress])
}

model NewsletterSubscription {
  id          Int       @id @default(autoincrement())
  email       String    @unique
  status      String    @default("active") // active, unsubscribed
  source      String    @default("landing_page") // landing_page, pricing_page, etc.
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@index([email])
  @@index([status])
}

// Vector-backed knowledge base models
model KnowledgeDoc {
  id          Int       @id @default(autoincrement())
  source      String    // curated, theproductfolks, generated, article
  title       String
  content     String    @db.Text
  metadata    Json      @default("{}")
  embedding   Unsupported("vector(1536)")?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  flashcards  Flashcard[]

  @@index([source])
}

model ConversationMemory {
  id          Int              @id @default(autoincrement())
  userId      Int
  sessionId   Int?
  role        String           // user, assistant, system
  text        String           @db.Text
  category    String?
  metadata    Json             @default("{}")
  embedding   Unsupported("vector(1536)")?
  createdAt   DateTime         @default(now())

  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  session     PracticeSession? @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sessionId])
  @@index([category])
}

model ResumeProfile {
  id          Int       @id @default(autoincrement())
  userId      Int       @unique
  rawText     String    @db.Text
  structured  Json      @default("{}")
  embedding   Unsupported("vector(1536)")?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model ExemplarAnswer {
  id          Int       @id @default(autoincrement())
  questionId  Int
  source      String    // theproductfolks, ai_generated, curated
  author      String?
  title       String?
  content     String    @db.Text
  keyPoints   Json?
  qualityScore Int      @default(10)
  version     Int       @default(1)
  sourceUrl   String?
  sourceHash  String?
  embedding   Unsupported("vector(1536)")?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  question    Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([questionId, source, version])
  @@index([questionId])
  @@index([source])
}

model JobPosting {
  id              Int       @id @default(autoincrement())
  source          String    // linkedin, indeed, google_jobs, ycombinator
  url             String    @unique
  title           String
  company         String
  location        String?
  rawText         String?   @db.Text
  metadata        Json      @default("{}")
  embedding       Unsupported("vector(1536)")?
  postedAt        DateTime?
  scrapedAt       DateTime  @default(now())
  createdAt       DateTime  @default(now())

  recommendations JobRecommendation[]

  @@index([source])
  @@index([company])
  @@index([postedAt])
}

model JobRecommendation {
  id          Int       @id @default(autoincrement())
  userId      Int
  jobId       Int
  score       Decimal   @db.Decimal(3, 2)
  sentAt      DateTime  @default(now())

  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  job         JobPosting @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([userId, jobId])
  @@index([userId])
  @@index([sentAt])
}

model Flashcard {
  id              Int       @id @default(autoincrement())
  knowledgeDocId  Int
  question        String    @db.Text
  answer          String    @db.Text
  category        String?
  difficulty      String?   // easy, medium, hard
  metadata        Json      @default("{}")
  createdAt       DateTime  @default(now())

  knowledgeDoc    KnowledgeDoc @relation(fields: [knowledgeDocId], references: [id], onDelete: Cascade)
  progress        FlashcardProgress[]

  @@index([knowledgeDocId])
  @@index([category])
}

model FlashcardProgress {
  id            Int       @id @default(autoincrement())
  userId        Int
  flashcardId   Int
  lastReviewed  DateTime?
  nextReview    DateTime?
  easeFactor    Decimal   @default(2.5) @db.Decimal(3, 2)
  interval      Int       @default(1)
  repetitions   Int       @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  flashcard     Flashcard @relation(fields: [flashcardId], references: [id], onDelete: Cascade)

  @@unique([userId, flashcardId])
  @@index([userId])
  @@index([nextReview])
}

model AgentExecution {
  id          Int       @id @default(autoincrement())
  userId      Int?
  agentType   String    // evaluator, interviewer, curriculum, jobScout, etc.
  input       String    @db.Text // JSON string
  output      String?   @db.Text // JSON string, nullable
  toolCalls   String    @db.Text @default("[]") // JSON array of tool calls
  tokensUsed  Int       @default(0)
  durationMs  Int       @default(0)
  status      String    @default("success") // success, error
  error       String?   @db.Text
  createdAt   DateTime  @default(now())

  @@index([userId])
  @@index([agentType])
  @@index([status])
  @@index([createdAt])
}

model JobMatcherPreferences {
  id                  Int       @id @default(autoincrement())
  userId              Int       @unique
  resumeFilePath      String?   // Path to saved resume file
  resumeFileData      Bytes?    // Binary data of the resume file (PDF/DOCX)
  resumeFileName      String?   // Original filename
  resumeFileType      String?   // MIME type (application/pdf, application/vnd.openxmlformats-officedocument.wordprocessingml.document)
  userEmail           String
  jobIntentText       String    @db.Text
  desiredRole         String?
  companyPrefs        String?
  locationPref        String?
  remotePref          String?
  enableLinkedInSearch Boolean  @default(false) // User preference to enable/disable LinkedIn search
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model UserSecret {
  id            Int       @id @default(autoincrement())
  userId        Int
  key           String    // e.g., 'linkedin_li_at', 'api_key', etc.
  ciphertext    String    @db.Text // Encrypted value
  nonce         String    // IV for decryption (hex)
  authTag       String    // GCM authentication tag (hex)
  status        String    @default("active") // active, invalid, expired
  lastTestedAt  DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, key])
  @@index([userId])
  @@index([key])
  @@index([status])
}

model JobMatchRun {
  id              String    @id @default(uuid())
  userId          Int?      // Link to user if logged in
  userEmail       String
  jobIntentText   String    @db.Text
  desiredRole     String?
  companyPrefs    String?
  locationPref    String?
  remotePref      String?
  resumeText      String?   @db.Text
  parsedProfile   Json?     // skills, titles, seniority, etc.
  status          String    @default("queued") // queued, running, emailed, error
  jobsFound       Int       @default(0)
  emailSentAt     DateTime?
  error           String?   @db.Text
  metadata        Json      @default("{}")
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user            User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  results         JobMatchResult[]

  @@index([userId])
  @@index([userEmail])
  @@index([status])
  @@index([createdAt])
}

model JobMatchResult {
  id              Int       @id @default(autoincrement())
  runId           String
  jobTitle        String
  company         String
  location        String?
  description     String?   @db.Text
  applyUrl        String
  salary          String?
  postedDate      String?
  source          String    // aggregator, linkedin
  score           Decimal   @db.Decimal(3, 2)
  rationale       String?   @db.Text
  rawData         Json      @default("{}")
  createdAt       DateTime  @default(now())

  run             JobMatchRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
  @@index([score])
}

model Secret {
  id          Int       @id @default(autoincrement())
  key         String    @unique
  value       String    @db.Text // Encrypted value
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([key])
}
